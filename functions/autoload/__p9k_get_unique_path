# vim:ft=zsh ts=2 sw=2 sts=2 et fenc=utf-8
################################################################
# @title powerlevel9k Autoload Function - __p9k_get_unique_path
# @sources
#   [powerlevel9k](https://github.com/bhilburn/powerlevel9k)
##
# @info
#   This file contains the __p9k_get_unique_path autoload function for
#   the powerlevel9k ZSH theme.
##

setopt localoptions # extendedglob

################################################################
# @description
#   Given a directory path, determine the unique path.
##
# @args
#   $1 string Absolute directory path to be truncated.
##
# @info
#   Takes paths like /abs/dir/path or ~/abs/home/dir/path but
#   not a relative path like ./dir/path or dir/path
#   The path "." will be ignored.
##
# @function __p9k_get_unique_path() {}
local full_path cur_path trunc_path directory test_dir
local -a paths
local -a matching

full_path="$1"
paths=(${(s:/:)full_path})
if [[ "${full_path}" == "." ]]; then
  return 0
elif [[ "${full_path}" == "~"* ]]; then
  # remove ~ from $paths and "move" $cur_paths to $HOME
  paths=(${paths[@]:1})
  cur_path="$HOME/"
  trunc_path='~/'
else
  cur_path='/'
  trunc_path='/'
fi

# for each parent path component find the shortest unique beginning
# characters sequence. Source: https://stackoverflow.com/a/45336078
for directory in ${paths}; do
  # finds out how many characters you need for the $directory to be unique
  test_dir=''
  matching=("$cur_path"*/)
  for (( i=0; i < ${#directory}; i++ )); do
    test_dir+="${directory:$i:1}"
    [[ ${(M)#matching:#${cur_path}${test_dir}*} -eq 1 ]] \
      && break
  done
  trunc_path+="${test_dir}/"
  cur_path+="${directory}/"
done

[[ ${#trunc_path} == 1 ]] \
  && echo "${trunc_path}" \
  || echo "${trunc_path: : -1}"
